// Generated by LiveScript 1.3.1
var ref$, fold1, map, b, o, single, rule, property, rankG, suitG, deconstructRed, deconstructBlack, redConstructor, blackConstructor, colorG, deconstructColor, colorConstructor, propertyG, deconstructAll, allConstruct, eachAndEveryG, allG, atLeastOneG, andDeconstructor, quantifierG, andG, ruleG;
ref$ = require('prelude-ls'), fold1 = ref$.fold1, map = ref$.map;
b = require('boomerang-grammar');
var types = require('./rule');
o = b.either;
single = function(f){
  return function(item){
    return [f(item)];
  };
};
var optionallyPlural = function(t) { return function(word){
  var plural, article, deconstructWord;
  plural = word === 'six'
    ? 'sixes'
    : word + 's';
  article = word === 'ace' ? 'an' : 'a';
  deconstructWord = function(thing){
    if (thing && thing[word]) {
      return [];
    } else {}
  };
  return [
    b.pure(function(){
      return t[word + ""];
    }, deconstructWord), o(plural, [article, word])
  ];
}};
var optionallyPluralRank = optionallyPlural(types.Rank);
rankG = b.any(map(optionallyPluralRank, ['ace', 'two', 'three', 'four', 'five', 'seven', 'eight', 'nine', 'ten', 'jack', 'queen', 'king']));
suitG = b.any(map(optionallyPlural(types.Suit), ['heart', 'club', 'diamond', 'spade']));
deconstructRed = function(color){ if (color.isred) return []; };
deconstructBlack = function(color){ if (color.isblack) return []; };
redConstructor = function(){
  return types.Color.red;
};
blackConstructor = function(){
  return types.Color.black;
};
colorG = o([
  b.pure(function(){
    return types.Color.red;
  }, deconstructRed), 'red'
], [
  b.pure(function(){
    return types.Color.black;
  }, deconstructBlack), 'black'
]);
deconstructColor = function(property){ if (property.isColor) return [property.color]; };
colorConstructor = function(color){ return types.Property.Color(color); };
propertyG = b.any([
  [b.pure(colorConstructor, deconstructColor), colorG], [
    b.pure(function(suit){ return types.Suit[suit]; }, single(function(it){ if (it.isSuit) return it.suit;
    })), suitG
  ], [
    b.pure(function(rank){ return types.Property.Rank(rank);
    }, single(function(it){ if (it.isRank) return it.rank;
    })), rankG
  ]
]);
deconstructAll = function(rule){ if (rule.isAll) return [rule.property]; };
allConstruct = function(property){ return types.Rule.All(property); };
eachAndEveryG = o(['each', b.optional(['and', 'every'])], 'every');
allG = [b.pure(allConstruct, deconstructAll), o([eachAndEveryG, 'card', 'is'], ['all', 'cards', 'are']), propertyG];
atLeastOneG = [
  b.pure(function(property){
    return types.Rule.AtLeastOne(property);
  }, single(function(it){ if (it.isAtLeastOne) return it.property;
  })), o([b.optional(['at', 'least']), 'one', o(['of', 'the', 'cards'], 'card'), 'is'], [o('a', 'any'), 'card', 'is']), propertyG
];
andDeconstructor = function(rule){ if (rule.isAnd) return [rule.left, rule.right];
};
quantifierG = b.any([allG, atLeastOneG]);
andG = [
  b.pure(function(left, right){ return types.Rule.And(left, right);
  }, andDeconstructor), quantifierG, 'and', b.recursive(function(){
    return ruleG;
  })
];
ruleG = [b.any([quantifierG, andG], b.eof)];
/*
rule-dictionary = { rule, property, color, suit, rank }

data Rule
  = And Rule Rule
  | Or Rule Rule
  | Not Rule
  | AtLeastOne Prop
  | AtMostOne Prop
  | None Prop
  | All Prop
  | Exactly Int Prop
  -- | Particular Which Prop -- not sure if this is necessary, but it makes the wording interesting
  | NumericalRelationship NumericalRelationship

data NumericalRelationship
  = Equals [Quantity] -- two or more
  | AllUnequal [Quantity] -- two or more
  | LT Quantity Quantity
  | LTE Quantity Quantity
  | GT Quantity Quantity
  | GTE Quantity Quantity

data Quantity
  = RawNumber Int
  | Sum Prop
  | Count Prop -- CountTrue just counts all of the cards
  | RankOf PositionProp
  | PositionOf SpecificCard

data Prop
  = Color Color
  | Suit Suit
  | Rank Rank -- might want to also make a suit+rank combo constructor, as that might actually be pretty easy
  | Face
  | And Prop Prop
  | Or Prop Prop
  | Not Prop
  | Implies Prop Prop
  | Xor Prop Prop
  | True
  | False
  | LT Rank
  | LTE Rank
  | GT Rank
  | GTE Rank
  | UniqueProp UniqueProp

data PositionProp =
  = First -- need to do some finagling to make sure that unique props are worded differently than non-unique props
  | Last
  | Position Int

data SpecificCard = SpecificCard Rank Suit

data Color
  = Red
  | Black

data Suit
  = Heart
  | Club
  | Suit
  | Spade


  all of the red cards are to the left of all of the black cards
  forall red. forall black. red before black
  all cards are of different rank
*/
module.exports = {
  colorConstructor: colorConstructor,
  colorG: colorG,
  deconstructColor: deconstructColor,
  optionallyPlural: optionallyPlural,
  propertyG: propertyG,
  rankG: rankG,
  ruleG: ruleG
};
