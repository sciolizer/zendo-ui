// Generated by LiveScript 1.3.1
var b, ev, e, r, Game, translate;
b = require('boomerang-grammar');
ev = require('./evaluate');
e = require('./english');
r = require('./random');
/*
type Card = String -- e.g. 2C, 7H, AD, JC, QH, KS, TH
*/

Game = (function(){
  Game.displayName = 'Game';
  var prototype = Game.prototype, constructor = Game;
  function Game(solution, rand){
    this.solution = solution;
    this.rand = rand;
    if (this.rand === void 8) {
      this.rand = {
        next: function(cap){
          return Math.floor(Math.random() * cap);
        }
      };
    }
  }
  prototype.markKoan = function(cards){
    return ev.evaluateTop(this.solution, cards);
  };
  prototype.evaluateRule = function(rule){
    var i$, x, size, cards, j$, y, underTheirRule, underCorrectRule;
    for (i$ = 1; i$ <= 1000; ++i$) {
      x = i$;
      cards = r.randomKoan(this.rand);
      underTheirRule = ev.evaluateTop(this.solution, cards);
      underCorrectRule = ev.evaluateTop(rule, cards);
      if (underTheirRule !== underCorrectRule) {
        return {
          counterExample: cards
        };
      }
    }
    return {
      win: {}
    };
  };
  return Game;
}());
translate = function(rule){
  var strings, isNewWord, topRule, iterator, words, item, stacks, understood, diff, expected, newStack, unparsed, otherSentences, stack, sentence;
  strings = rule.trim().split(/\s+/);
  isNewWord = rule.slice(-1) === ' ' && rule.trim().length > 0;
  topRule = e.ruleG;
  iterator = b.parse(topRule, strings);
  words = [];
  item = iterator.next();
  stacks = [];
  understood = 0;
  while (!item.done) {
    diff = strings.length - item.value.strings.length;
    if (diff > understood) {
      understood = diff;
    }
    if (item.value.strings.length === 0) {
      if (item.value.error) {
        expected = item.value.expected;
        if (expected === "<eof>") {
          throw new Error("impossible");
        } else {
          if (isNewWord) {
            if (words.indexOf(expected) === -1) {
              words.push(expected);
            }
          } else {
            if (words.indexOf('<space>') === -1) {
              words.push('<space>');
            }
          }
        }
      } else {
        newStack = item.value.stackModifier([]);
        stacks.push(newStack);
        if (words.indexOf("<enter>") === -1) {
          words.push("<enter>");
        }
      }
    } else if (item.value.strings.length === 1) {
      unparsed = item.value.strings[0];
      if (item.value.error) {
        expected = item.value.expected;
        if (!isNewWord) {
          if (expected.indexOf(unparsed) === 0) {
            if (words.indexOf(expected) === -1) {
              words.push(expected);
            }
          }
        }
      }
    }
    item = iterator.next();
  }
  if (stacks.length > 1) {
    console.log('stacks', stacks);
  }
  otherSentences = [];
  if (stacks.length > 0) {
    stack = stacks[0];
    iterator = b.print(topRule, stack);
    item = iterator.next();
    while (!item.done) {
      sentence = item.value.strings.join(" ");
      if (otherSentences.indexOf(sentence) === -1) {
        otherSentences.push(sentence);
      }
      item = iterator.next();
    }
  }
  words.sort();
  otherSentences.sort();
  var first;
  for (var prop in stack) {
    first = stack[prop];
    break;
  }
  return {
    understood: understood,
    suggestions: words,
    paraphrases: otherSentences,
    rule: first
  };
};
module.exports = {
  Game: Game,
  randomRule: r.randomRule,
  translate: translate
};
