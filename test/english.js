// Generated by LiveScript 1.3.1
var assert, b, english, ParseTester;
assert = require('assert');
b = require('boomerang-grammar');
english = require('../src/english');
var types = require('../src/rule');
var adt = require('adt');
describe('optionally-plural', function(){
  var x$;
  x$ = it;
  x$('should parse plural', function(){
    var parser, iterator, pt;
    parser = english.optionallyPlural(types.Rank)('two');
    iterator = b.parse(parser, ['twos']);
    pt = new ParseTester(iterator);
    assert(types.Rank.two.equals(types.Rank['two']));
    pt.success([], [types.Rank.two], []);
    return pt.done;
  });
  x$('should parse singular', function(){
    var Gratitude = adt.enum('thank', 'appreciate', 'a', 'you');
    var parser, iterator, pt;
    parser = english.optionallyPlural(Gratitude)('thank');
    iterator = b.parse(parser, ['a', 'thank', 'you']);
    pt = new ParseTester(iterator);
    pt.errorExpect('thanks');
    pt.success([], [Gratitude.thank], ['you']);
    return pt.done;
  });
  return x$;
});
describe('rank-g', function(){
  var x$;
  x$ = it;
  x$('should parse aces', function(){
    var iterator, pt;
    iterator = b.parse(english.rankG, ['aces']);
    pt = new ParseTester(iterator);
    return pt.success([], [types.Rank.ace]);
  });
  x$('should parse a two', function(){
    var iterator, pt;
    iterator = b.parse(english.rankG, ['a', 'two']);
    pt = new ParseTester(iterator);
    pt.errorExpect("aces");
    pt.errorExpect("an");
    pt.errorExpect("twos");
    return pt.success([], [types.Rank.two]);
  });
  return x$;
});
describe('red', function(){
  var x$;
  x$ = it;
  x$('should become a color via color-g', function(){
    var iterator, pt;
    iterator = b.parse(english.colorG, ['red', 'medallion']);
    pt = new ParseTester(iterator);
    pt.success([], [types.Color.red], ['medallion']);
    return pt.done;
  });
  //x$('should become a property via constructors', function(){
  //  var parser, iterator, pt;
  //  parser = [b.pure(english.colorConstructor, english.deconstructColor), english.colorG];
  //  iterator = b.parse(parser, ['red', 'medallion']);
  //  pt = new ParseTester(iterator);
  //  pt.success([], [{
  //    isColor: {
  //      color: {
  //        red: {}
  //      }
  //    }
  //  }], ['medallion']);
  //  return pt.done;
  //});
  //x$('should become a property via any constructors', function(){
  //  var parser, iterator, pt;
  //  parser = b.any([[b.pure(english.colorConstructor, english.deconstructColor), english.colorG]]);
  //  iterator = b.parse(parser, ['red', 'medallion']);
  //  pt = new ParseTester(iterator);
  //  pt.success([], [{
  //    isColor: {
  //      color: {
  //        red: {}
  //      }
  //    }
  //  }], ['medallion']);
  //  return pt.done;
  //});
  return x$;
});
/*
  .. 'should become a property via color-g' ->
    iterator = b.parse english.property-g, <[red medallion]>
    pt = new Parse-tester iterator
    pt.success [], [{isColor:{color:{red:{}}}}], <[medallion]>
    pt.done
*/
describe('example-rule', function(){
  var x$;
  x$ = it;
  //x$('should parse a card is black', function(){
  //  var parser, iterator, item, value, stack;
  //  parser = english.ruleG;
  //  iterator = b.parse(parser, ['a', 'card', 'is', 'black']);
  //  item = iterator.next();
  //  value = void 8;
  //  while (!item.done) {
  //    if (!item.value.error) {
  //      value = item.value;
  //      break;
  //    }
  //    item = iterator.next();
  //  }
  //  assert.equal(value.strings.length, 0);
  //  stack = value.stackModifier([]);
  //  return assert.deepEqual(stack, [{
  //    atLeastOne: {
  //      property: {
  //        isColor: {
  //          color: {
  //            black: {}
  //          }
  //        }
  //      }
  //    }
  //  }]);
  //});
  return x$;
});
ParseTester = (function(){
  ParseTester.displayName = 'ParseTester';
  var prototype = ParseTester.prototype, constructor = ParseTester;
  function ParseTester(iterator){
    this.iterator = iterator;
  }
  prototype.errorExpect = function(expected, strings){
    var item;
    item = this.iterator.next();
    assert.equal(false, item.done);
    assert.equal(true, item.value.error);
    if (expected !== void 8) {
      assert.equal(expected, item.value.expected);
    }
    if (strings !== void 8) {
      return assert.deepEqual(strings, item.value.strings);
    }
  };
  prototype.success = function(stackInput, stackOutput, strings){
    var item, newStack;
    item = this.iterator.next();
    assert.equal(false, item.done);
    if (item.value.error) {
      assert.fail("error, unexpected: " + item.value.expected, "successful parse", "expected successful parse, actual error expecting: " + item.value.expected, "next");
    }
    if (void 8 !== strings) {
      assert.deepEqual(strings, item.value.strings);
    }
    if (void 8 !== stackInput) {
      newStack = item.value.stackModifier(stackInput);
      assert.equal(stackOutput.length, newStack.length);
      for (var i = 0; i < stackOutput.length; i++) {
        if (typeof stackOutput[i] === "string") {
          assert(stackOutput[i] == newStack[i]);
        } else {
          assert(stackOutput[i].equals(newStack[i]));
        }
      }
      //return assert.deepEqual(stackOutput, newStack);
    }
  };
  prototype.done = function(){
    var item;
    item = this.iterator.next();
    return assert.equal(true, item.done);
  };
  return ParseTester;
}());
