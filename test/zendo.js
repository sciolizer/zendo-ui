// Generated by LiveScript 1.3.1
var assert, z;
assert = require('assert');
z = require('../src/zendo');
var types = require('../src/rule');
describe('partial-translations', function(){
  var x$;
  x$ = it;
  x$('should make suggestions for the empty string', function(){
    var translation;
    translation = z.translate('');
    assert.equal(translation.understood, 0);
    assert.deepEqual(translation.suggestions, ['a', 'all', 'any', 'at', 'each', 'every', 'one']);
    assert.deepEqual(translation.paraphrases, []);
    return assert.equal(translation.rule, void 8);
  });
  x$('should make suggestions for a string of one space', function(){
    var translation;
    translation = z.translate(' ');
    assert.equal(translation.understood, 0);
    assert.deepEqual(translation.suggestions, ['a', 'all', 'any', 'at', 'each', 'every', 'one']);
    assert.deepEqual(translation.paraphrases, []);
    return assert.equal(translation.rule, void 8);
  });
  x$('should make suggestions for a string of two spaces', function(){
    var translation;
    translation = z.translate('  ');
    assert.equal(translation.understood, 0);
    assert.deepEqual(translation.suggestions, ['a', 'all', 'any', 'at', 'each', 'every', 'one']);
    assert.deepEqual(translation.paraphrases, []);
    return assert.equal(translation.rule, void 8);
  });
  x$('should suggest only words beginning with a', function(){
    var translation;
    translation = z.translate('a');
    assert.equal(translation.understood, 1);
    assert.deepEqual(translation.suggestions, ['<space>', 'all', 'any', 'at']);
    assert.deepEqual(translation.paraphrases, []);
    return assert.equal(translation.rule, void 8);
  });
  x$('should suggest more words after the space', function(){
    var translation;
    translation = z.translate('a ');
    assert.equal(translation.understood, 1);
    assert.deepEqual(translation.suggestions, ['card']);
    assert.deepEqual(translation.paraphrases, []);
    return assert.equal(translation.rule, void 8);
  });
  x$('should suggest only card after a c', function(){
    var translation;
    translation = z.translate('a c');
    assert.equal(translation.understood, 1);
    assert.deepEqual(translation.suggestions, ['card']);
    assert.deepEqual(translation.paraphrases, []);
    return assert.equal(translation.rule, void 8);
  });
  x$('should suggest only card after a car', function(){
    var translation;
    translation = z.translate('a car');
    assert.equal(translation.understood, 1);
    assert.deepEqual(translation.suggestions, ['card']);
    assert.deepEqual(translation.paraphrases, []);
    return assert.equal(translation.rule, void 8);
  });
  x$('should suggest nothing after a b', function(){
    var translation;
    translation = z.translate('a b');
    assert.equal(translation.understood, 1);
    assert.deepEqual(translation.suggestions, []);
    assert.deepEqual(translation.paraphrases, []);
    return assert.equal(translation.rule, void 8);
  });
  x$('should suggest only <space> after a card', function(){
    var translation;
    translation = z.translate('a card');
    assert.equal(translation.understood, 2);
    assert.deepEqual(translation.suggestions, ['<space>']);
    assert.deepEqual(translation.paraphrases, []);
    return assert.equal(translation.rule, void 8);
  });
  x$('should suggest words after a card <space>', function(){
    var translation;
    translation = z.translate('a card ');
    assert.equal(translation.understood, 2);
    assert.deepEqual(translation.suggestions, ['is']);
    assert.deepEqual(translation.paraphrases, []);
    return assert.equal(translation.rule, void 8);
  });
  x$('should suggest words after a card <multiple spaces>', function(){
    var translation;
    translation = z.translate('a card  ');
    assert.equal(translation.understood, 2);
    assert.deepEqual(translation.suggestions, ['is']);
    assert.deepEqual(translation.paraphrases, []);
    return assert.equal(translation.rule, void 8);
  });
  x$('should suggest only all for al', function(){
    var translation;
    translation = z.translate('al');
    assert.equal(translation.understood, 0);
    assert.deepEqual(translation.suggestions, ['all']);
    assert.deepEqual(translation.paraphrases, []);
    return assert.equal(translation.rule, void 8);
  });
  x$('should suggest nothing for al and a space', function(){
    var translation;
    translation = z.translate('al ');
    assert.equal(translation.understood, 0);
    assert.deepEqual(translation.suggestions, []);
    assert.deepEqual(translation.paraphrases, []);
    return assert.equal(translation.rule, void 8);
  });
  return x$;
});
describe('complete-translations', function(){
  var x$;
  x$ = it;
  x$('should consider a card is black to be a rule', function(){
    var translation;
    translation = z.translate('a card is black');
    assert.equal(translation.understood, 4);
    assert.deepEqual(translation.suggestions, ['<enter>', '<space>']);
    assert.deepEqual(translation.paraphrases, ['a card is black', 'any card is black', 'at least one card is black', 'at least one of the cards is black', 'one card is black', 'one of the cards is black']);
    assert(translation.rule.equals(types.Rule.AtLeastOne(types.Property.Color(types.Color.black))));
  });
  return x$;
});
/*
suggest <enter> even when last character is not a space
random-rule - just do a pretty-print and make sure it has at least one output 
suggest <space>
before space is entered, most recent characters must be prefix of all suggestions
no duplicate paraphrases
no duplicate word suggestions
*/
describe('Game', function(){
  var x$;
  x$ = it;
  var allRed = types.Rule.All(types.Property.Color(types.Color.red));
  var game = new z.Game(allRed);
  x$('should mark the all red koan as true', function(){
    return assert.equal(game.markKoan(["2H", "TD"]), true);
  });
  x$('should generate counter example', function(){
    result = game.evaluateRule(types.Rule.AtLeastOne(types.Property.Color(types.Color.red)));
    return assert(result.counterExample.length !== 1, "" + result.counterExample.length + " != 1");
  });
  x$('should return win for identical rules', function(){
    result = game.evaluateRule(allRed);
    assert.deepEqual(result.win, {});
  });
  return x$;
});
